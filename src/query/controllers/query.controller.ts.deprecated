import {
  Body,
  Controller,
  Delete,
  Get,
  Header,
  Param,
  Patch,
  Post,
  Query,
  Version,
} from '@nestjs/common';
import { QueryService } from '../services/query.service';

import { ApiExtraModels, ApiOkResponse } from '@nestjs/swagger';
import { InjectRepository } from '@nestjs/typeorm';
import { isArray } from 'class-validator';
import { BaseEntity, Repository } from 'typeorm';
import {
  applyFilter,
  applySort,
  getAllEditableFields,
  getAllSortableFields,
  getAllViewableFields,
  getEntityMeta,
  getFilterableFields
} from '../helpers';
import { QueryRequest } from '../requests';
import { IQueryPaginationResource, PaginationMeta, createSearchResponse } from '../resources';

export const QueryController = (entity: typeof BaseEntity) => {
  const searchResponse = createSearchResponse(entity.name,entity);

  @Controller({
    version: ['1'],
  })
  @ApiExtraModels(entity)
  //@AccessTokenRequired()
  //@ApiBearerAuth()
  abstract class QueryController<T = typeof entity> {

    _dbTempEntity: T;

    constructor(
      @InjectRepository(entity)
      readonly repository: Repository<T>,
      readonly queryService: QueryService,
    ) {
      this._dbTempEntity = this.repository.create();
    }


    @Get('collection')
    @Version('1')
    @ApiOkResponse({
      description: 'The user records',
      type: searchResponse<T>,
    })
    public async getCollectionGet(@Query()  options: QueryRequest){
      return await this.getCollection(options)
    }

    @Post('collection')
    @Version('1')
    @ApiOkResponse({
      description: 'The user records',
      type: searchResponse<T>,
    })
    public async getCollectionPost(@Body()  options: QueryRequest){
      return await this.getCollection(options)
    }

    public async getCollection(
       options: QueryRequest,
    ): Promise<IQueryPaginationResource<T>> {
      const queryBuilder = this.repository.createQueryBuilder();
      queryBuilder.skip(options.skip).take(options.take);

      const itemCount = await queryBuilder.getCount();

      if (options.sort !== undefined && isArray(options.sort)) {
        for (let item of options.sort) {
          applySort(this._dbTempEntity, item, queryBuilder);
        }
      }

      if (options.filter !== undefined && isArray(options.filter)) {
        for (let item of options.filter) {
          applyFilter(this._dbTempEntity, item, queryBuilder);
        }
      }
      const { entities } = await queryBuilder.getRawAndEntities<T>();
      const pageMetaDto = new PaginationMeta({ itemCount, options });
      return new searchResponse<T>(entities, pageMetaDto);
    }

    @Get('schema')
    @Version('1')
    @Header('Content-Type', 'application/json')
    public async schema() {
      return {
        fields: {
          viewable: getAllViewableFields(this._dbTempEntity),
          editable: getAllEditableFields(this._dbTempEntity),
          sortable: getAllSortableFields(this._dbTempEntity),
          filterable: getFilterableFields(this._dbTempEntity),
        },
        entity: getEntityMeta(this._dbTempEntity),
      };
    }

    @Post('item')
    @Version('1')
    public async create(@Body() createUserDto) {}


    @Get('item/:id')
    @Version('1')
    public async findOne(@Param('id') id: string) {}

    @Patch('item/:id')
    @Version('1')
    public async update(@Param('id') id: string, @Body() data: T) {
      return data;
    }

    @Delete('item/:id')
    @Version('1')
    public async remove(@Param('id') id: string) {}
  }

  return QueryController;
};
